---
property: JSON-RPC Client Library for MCP Communication

“””
JSON-RPC Client Library for MCP Communication

A reusable library for handling JSON-RPC communication with MCP servers.
Supports multiple protocol versions and provides a clean abstraction.
“””

import asyncio
import json
import structlog
from typing import Dict, Any, Optional, TypeVar, Generic, Callable, List
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod

logger = structlog.get_logger()

T = TypeVar(‘T’)

class ProtocolVersion(Enum):
“”“Known MCP protocol versions”””
V0_1_0 = “0.1.0”
V2024_11_05 = “2024-11-05”  
V2025_06_18 = “2025-06-18”

@dataclass
class JsonRpcRequest:
“”“JSON-RPC 2.0 Request”””
method: str
params: Dict[str, Any]
id: Optional[int] = None

```
def to_dict(self) -> Dict[str, Any]:
    d = {
        "jsonrpc": "2.0",
        "method": self.method,
        "params": self.params
    }
    if self.id is not None:
        d["id"] = self.id
    return d
```

@dataclass
class JsonRpcResponse:
“”“JSON-RPC 2.0 Response”””
result: Optional[Any] = None
error: Optional[Dict[str, Any]] = None
id: Optional[int] = None

```
@classmethod
def from_dict(cls, data: Dict[str, Any]) -> 'JsonRpcResponse':
    return cls(
        result=data.get("result"),
        error=data.get("error"),
        id=data.get("id")
    )

def is_error(self) -> bool:
    return self.error is not None
```

class JsonRpcTransport(ABC):
“”“Abstract transport for JSON-RPC communication”””

```
@abstractmethod
async def send(self, data: str) -> None:
    """Send data to the server"""
    pass

@abstractmethod
async def receive(self) -> str:
    """Receive data from the server"""
    pass

@abstractmethod
async def close(self) -> None:
    """Close the transport"""
    pass
```

class SubprocessTransport(JsonRpcTransport):
“”“Transport using subprocess stdin/stdout”””

```
def __init__(self, process: asyncio.subprocess.Process):
    self.process = process
    
async def send(self, data: str) -> None:
    self.process.stdin.write(data.encode())
    await self.process.stdin.drain()
    
async def receive(self) -> str:
    line = await self.process.stdout.readline()
    return line.decode()
    
async def close(self) -> None:
    if self.process:
        self.process.terminate()
        await self.process.wait()
```

class JsonRpcClient:
“”“Generic JSON-RPC client with protocol version support”””

```
def __init__(self, transport: JsonRpcTransport, protocol_version: ProtocolVersion = ProtocolVersion.V2025_06_18):
    self.transport = transport
    self.protocol_version = protocol_version
    self._request_id = 0
    self._pending_requests: Dict[int, asyncio.Future] = {}
    self._reader_task: Optional[asyncio.Task] = None
    self._notification_handlers: Dict[str, List[Callable]] = {}
    
async def start(self):
    """Start the client and reader task"""
    self._reader_task = asyncio.create_task(self._read_responses())
    
async def stop(self):
    """Stop the client"""
    if self._reader_task:
        self._reader_task.cancel()
        try:
            await self._reader_task
        except asyncio.CancelledError:
            pass
    await self.transport.close()
    
async def _read_responses(self):
    """Continuously read responses from transport"""
    while True:
        try:
            line = await self.transport.receive()
            if not line:
                break
                
            try:
                data = json.loads(line)
                
                # Check if it's a notification
                if "method" in data and "id" not in data:
                    await self._handle_notification(data)
                # Otherwise it's a response
                elif "id" in data and data["id"] in self._pending_requests:
                    response = JsonRpcResponse.from_dict(data)
                    future = self._pending_requests.pop(data["id"])
                    
                    if response.is_error():
                        future.set_exception(Exception(response.error["message"]))
                    else:
                        future.set_result(response.result)
                        
            except json.JSONDecodeError:
                logger.error("Invalid JSON response", line=line.strip())
                
        except Exception as e:
            logger.error("Error reading response", error=str(e))
            break

async def _handle_notification(self, data: Dict[str, Any]):
    """Handle incoming notifications"""
    method = data["method"]
    params = data.get("params", {})
    
    if method in self._notification_handlers:
        for handler in self._notification_handlers[method]:
            try:
                await handler(params)
            except Exception as e:
                logger.error("Error in notification handler", 
                           method=method, error=str(e))

def on_notification(self, method: str, handler: Callable):
    """Register a notification handler"""
    if method not in self._notification_handlers:
        self._notification_handlers[method] = []
    self._notification_handlers[method].append(handler)

async def request(self, method: str, params: Dict[str, Any] = None) -> Any:
    """Send a request and wait for response"""
    self._request_id += 1
    request = JsonRpcRequest(
        method=method,
        params=params or {},
        id=self._request_id
    )
    
    # Create future for response
    future = asyncio.get_event_loop().create_future()
    self._pending_requests[request.id] = future
    
    # Send request
    request_str = json.dumps(request.to_dict()) + "\n"
    await self.transport.send(request_str)
    
    # Wait for response with timeout
    try:
        result = await asyncio.wait_for(future, timeout=30.0)
        return result
    except asyncio.TimeoutError:
        self._pending_requests.pop(request.id, None)
        raise Exception(f"Request timeout for {method}")

async def notify(self, method: str, params: Dict[str, Any] = None):
    """Send a notification (no response expected)"""
    notification = JsonRpcRequest(
        method=method,
        params=params or {}
    )
    
    notification_str = json.dumps(notification.to_dict()) + "\n"
    await self.transport.send(notification_str)
```

class MCPClient(JsonRpcClient):
“”“MCP-specific JSON-RPC client”””

```
def __init__(self, transport: JsonRpcTransport, 
             protocol_version: ProtocolVersion = ProtocolVersion.V2025_06_18,
             client_info: Dict[str, str] = None):
    super().__init__(transport, protocol_version)
    self.client_info = client_info or {
        "name": "mcp-json-rpc-client",
        "version": "1.0.0"
    }
    self.server_info: Optional[Dict[str, Any]] = None
    self.available_tools: List[str] = []
    
async def initialize(self) -> Dict[str, Any]:
    """Initialize MCP session"""
    result = await self.request("initialize", {
        "protocolVersion": self.protocol_version.value,
        "capabilities": {},
        "clientInfo": self.client_info
    })
    
    self.server_info = result.get("serverInfo")
    logger.info("MCP session initialized", 
               server_info=self.server_info,
               protocol_version=result.get("protocolVersion"))
    
    # Send initialized notification
    await self.notify("notifications/initialized")
    
    # Get available tools
    await self.list_tools()
    
    return result

async def list_tools(self) -> List[Dict[str, Any]]:
    """List available tools"""
    result = await self.request("tools/list", {})
    tools = result.get("tools", [])
    self.available_tools = [tool["name"] for tool in tools]
    logger.info("Available tools", tools=self.available_tools)
    return tools

async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:
    """Call a tool"""
    if tool_name not in self.available_tools:
        logger.warning("Tool not available", tool=tool_name, 
                     available=self.available_tools)
    
    result = await self.request("tools/call", {
        "name": tool_name,
        "arguments": arguments
    })
    
    return result
```

class MCPServerLauncher:
“”“Helper to launch MCP servers”””

```
@staticmethod
async def launch_supabase(project_ref: str, access_token: str) -> MCPClient:
    """Launch Supabase MCP server and return client"""
    logger.info("Launching Supabase MCP server", project_ref=project_ref[:8] + "...")
    
    process = await asyncio.create_subprocess_exec(
        "npx", "-y", "@supabase/mcp-server-supabase@latest",
        "--project-ref", project_ref,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
        stdin=asyncio.subprocess.PIPE,
        env={
            "SUPABASE_ACCESS_TOKEN": access_token,
            **os.environ
        }
    )
    
    # Create transport and client
    transport = SubprocessTransport(process)
    client = MCPClient(transport, ProtocolVersion.V2025_06_18, {
        "name": "supabase-client",
        "version": "1.0.0"
    })
    
    # Start client and initialize
    await client.start()
    await asyncio.sleep(2)  # Give server time to start
    await client.initialize()
    
    return client

@staticmethod
async def launch_filesystem(allowed_directories: List[str]) -> MCPClient:
    """Launch filesystem MCP server and return client"""
    # Example for other MCP servers
    pass
```

# Example usage with type-safe wrapper

class SupabaseMCPClient:
“”“Type-safe wrapper for Supabase MCP operations”””

```
def __init__(self, mcp_client: MCPClient):
    self.client = mcp_client
    
async def execute_sql(self, query: str) -> Dict[str, Any]:
    """Execute SQL with proper typing"""
    result = await self.client.call_tool("execute_sql", {"query": query})
    
    # Parse the response
    if "content" in result and isinstance(result["content"], list):
        for item in result["content"]:
            if item.get("type") == "text":
                try:
                    return json.loads(item["text"])
                except json.JSONDecodeError:
                    return {"error": "Invalid response format"}
    
    return result
```

# Example usage

async def example_usage():
“”“Example of using the JSON-RPC client library”””
import os

```
# Launch Supabase MCP server
client = await MCPServerLauncher.launch_supabase(
    project_ref=os.getenv("SUPABASE_PROJECT_REF"),
    access_token=os.getenv("SUPABASE_ACCESS_TOKEN")
)

# Create type-safe wrapper
supabase = SupabaseMCPClient(client)

try:
    # Execute SQL
    result = await supabase.execute_sql("SELECT current_timestamp;")
    print(f"Current time: {result}")
    
finally:
    # Clean up
    await client.stop()
```

if **name** == “**main**”:
asyncio.run(example_usage())
---
